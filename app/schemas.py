from pydantic import Field
from typing import Annotated, List, Optional
from datetime import date, datetime
from pydantic import ConfigDict, field_validator

from .custom_types import FormattedDate
from .models import BCItem
from .enum import ProjectType, UserRole, ItemGlobalStatus, ValidationState,  ProjectType, UserRole 
from pydantic import BaseModel, EmailStr
# --- 1. UserBase: Defines all the fields a user CAN have. ---
# It does NOT include fields generated by the server like `id` or `is_active`.
class UserBase(BaseModel):
    username: str
    email: str
    first_name: str
    last_name: str
    role: UserRole
    birth_date: Optional[FormattedDate] = None
    cin: Optional[str] = None
    cnss: Optional[str] = None
    rib: Optional[str] = None
    phone_number: Optional[str] = None
    address: Optional[str] = None
    city: Optional[str] = None
    hire_date: Optional[FormattedDate] = None
    job_title: Optional[str] = None
    daily_rate: Optional[float] = None


# --- 2. UserCreate: For CREATING a user. ---
# It inherits all the fields from UserBase and adds the password.
# This is the schema your /register endpoint should use for INPUT.
class UserCreate(UserBase):
    password: str


# --- 3. User: For READING a user. ---
# It inherits all the fields from UserBase and adds the server-generated fields.
# This is the schema your endpoints should use for OUTPUT.
class User(UserBase):
    id: int
    is_active: bool

    model_config = ConfigDict(from_attributes=True)
class UserUpdate(BaseModel):
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    job_title: Optional[str] = None
    hire_date: Optional[date] = None
    phone_number: Optional[str] = None
    email: Optional[EmailStr] = None
    role: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)
class UserInfo(BaseModel):
    id: int
    first_name: str
    last_name: str
    
    model_config = ConfigDict(from_attributes=True)

class AccountBase(BaseModel):
    name: str

class AccountCreate(AccountBase):
    pass

class Account(AccountBase):
    id: int
    model_config = ConfigDict(from_attributes=True)

class CustomerBase(BaseModel):
    name: str
    short_name: Optional[str] = None

class CustomerCreate(CustomerBase):
    pass

class Customer(CustomerBase):
    id: int
    model_config = ConfigDict(from_attributes=True)


class ProjectBase(BaseModel):
    name: str
    
    # --- CHANGE 1: Use the Enum for project_type ---
    project_type: Optional[ProjectType] = None
    
    start_date: Optional[FormattedDate] = None
    plan_end_date: Optional[FormattedDate] = None
    has_extension_possibility: Optional[bool] = False
    
    # We are removing project_manager_name
    
    forecast_plan_details: Optional[str] = None
    budget_assigned: Optional[float] = None
    budget_period: Optional[str] = None
    
    # We will accept IDs for the related objects
    account_id: Optional[int] = None
    direct_customer_id: Optional[int] = None
    final_customer_id: Optional[int] = None
    
    # --- CHANGE 2: Accept a project_manager_id ---
    project_manager_id: Optional[int] = None

class ProjectCreate(ProjectBase):
    pass

# This schema is for reading a Project. It will include the full nested objects.
class Project(ProjectBase):
    id: int
    account: Optional[Account] = None
    direct_customer: Optional[Customer] = None
    final_customer: Optional[Customer] = None
    
    # --- CHANGE 3: Return the full User object ---
    project_manager: Optional[User] = None
    
    model_config = ConfigDict(from_attributes=True)

class PurchaseOrderBase(BaseModel):
    due_qty: float
    po_status: str
    unit_price: float
    line_amount: float
    billed_quantity: float
    po_no: str
    po_line_no: int
    item_code: str
    requested_qty: float
    publish_date: FormattedDate
    project_code: str
    payment_terms_raw: Optional[str] = None # Add to schema

class PurchaseOrderCreate(PurchaseOrderBase):
    pass

class RawPurchaseOrder(PurchaseOrderBase):
    id: int
    is_processed: bool
    model_config = ConfigDict(from_attributes=True)
class InternalProject(BaseModel):
    id: int
    name: str
    project_manager: Optional[User] = None
    project_type: Optional[ProjectType] = None
    start_date: Optional[FormattedDate] = None
    plan_end_date: Optional[FormattedDate] = None
    has_extension_possibility: Optional[bool] = None
    forecast_plan_details: Optional[str] = None
    budget_assigned: Optional[float] = None
    budget_period: Optional[str] = None
    account: Optional[Account] = None
    direct_customer: Optional[Customer] = None
    final_customer: Optional[Customer] = None

    model_config = ConfigDict(from_attributes=True)
class InternalProjectCreate(BaseModel):
    name: str
    # Use the Enum here
    project_type: ProjectType 
    
    # Dates can be passed as YYYY-MM-DD strings, Pydantic handles the parsing
    start_date: Optional[date] = None
    plan_end_date: Optional[date] = None
    
    has_extension_possibility: bool = False
    forecast_plan_details: Optional[str] = None
    budget_assigned: Optional[float] = None
    budget_period: Optional[str] = None
    
    # Foreign Keys
    project_manager_id: Optional[int] = None
    account_id: Optional[int] = None
    direct_customer_id: Optional[int] = None
    final_customer_id: Optional[int] = None
class InternalProjectUpdate(InternalProjectCreate):
    pass

class CustomerProject(BaseModel):
    id: int
    name: str
    
    model_config = ConfigDict(from_attributes=True)
class SiteAssignmentRuleCreate(BaseModel):
    # All criteria are optional, but at least one should ideally be provided
    starts_with: Optional[str] = None
    ends_with: Optional[str] = None
    contains_str: Optional[str] = None
    
    customer_project_id: Optional[int] = None
    
    min_publish_date: Optional[date] = None
    max_publish_date: Optional[date] = None
        
    internal_project_id: int # Mandatory target

class SiteAssignmentRule(SiteAssignmentRuleCreate):
    id: int
    # We include nested objects for the UI table
    internal_project: Optional[InternalProject] = None 
    customer_project: Optional[CustomerProject] = None # Assuming you have a basic schema for this
    
    model_config = ConfigDict(from_attributes=True)
class SiteAllocationCreate(BaseModel):
    site_id: int
    internal_project_id: int

class MergedPOBase(BaseModel):
    po_id: str
    customer_project: CustomerProject # This will be a nested object
    site_id: int
    site_code: Optional[str] = None
    internal_project: Optional[InternalProject] = None 

    po_no: str
    po_line_no: int
    item_description: Optional[str] = None
    payment_term: str
    unit_price: float
    requested_qty: float
    internal_control: int
    line_amount_hw: float
    publish_date: FormattedDate
    unit_price: Optional[float] = None # <--- REQUIRED FOR EDIT CALCULATION
    requested_qty: Optional[float] = None # <--- USEFUL TOO

    category: Optional[str] = None
    total_ac_amount: Optional[float] = None
    accepted_ac_amount: Optional[float] = None
    date_ac_ok: Optional[date] = None
  
    total_pac_amount: Optional[float] = None
    accepted_pac_amount: Optional[float] = None
    date_pac_ok: Optional[date] = None
    model_config = ConfigDict(from_attributes=True)

class MergedPO(MergedPOBase):
    id: int
    model_config = ConfigDict(from_attributes=True)

class PageMergedPO(BaseModel):
    items: List[MergedPO] # This uses your existing MergedPO schema
    total_items: int
    page: int
    per_page: int
    total_pages: int
class RemainingPO(MergedPO):
    remaining_amount: float
    remaining_stage: str # "AC" or "PAC"
    
    model_config = ConfigDict(from_attributes=True)

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

# in backend/app/schemas.py

# We already have a User schema for nesting, which is perfect.
# class User(UserBase): ...

class UploadHistoryBase(BaseModel):
    original_filename: str
    status: str
    total_rows: int
    error_message: Optional[str] = None

class UploadHistory(UploadHistoryBase):
    id: int
    uploaded_at: datetime
    uploader: User # Nest the full user object

    model_config = ConfigDict(from_attributes=True)


class PaginatedMergedPO(BaseModel):
    items: List[MergedPO]
    total_items: int
    page: int
    per_page: int
    total_pages: int

class PageSite(BaseModel):
    items: List["Site"]
    total_items: int
    page: int
    per_page: int
    total_pages: int
class SiteBase(BaseModel):
    site_code: str
    site_name: Optional[str] = None

class Site(SiteBase):
    id: int
    
    model_config = ConfigDict(from_attributes=True)
class FinancialSummary(BaseModel):
    total_po_value: float
    total_accepted_ac: float
    total_accepted_pac: float
    remaining_gap: float
    total_canceled: Optional[float] = 0.0 

   
class ProjectManagerInfo(BaseModel):
    first_name: Optional[str] = None
    last_name: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)

class ProjectFinancials(BaseModel):
    project_id: int
    project_name: str
    project_manager: Optional[ProjectManagerInfo] = None # Nested PM object

    total_po_value: float
    total_accepted: float
    remaining_gap: float
    completion_percentage: float

class MonthlyChartData(BaseModel):
    month: int
    total_po_value: float
    total_paid: float
    
class ProjectTargetSummary(BaseModel):
    project_name: str
    pm_name: str
    planned_budget: float
    actual_spent: float
    target_budget: float
    completion_rate: float

    model_config = ConfigDict(from_attributes=True)
class UserPerformanceSummary(BaseModel):
    total_po_value: float
    total_accepted: float
    remaining_gap: float
    completion_percentage: float
class UserTargetCreate(BaseModel):
    user_id: int
    year: int
    month: int
    target_po_amount: Optional[float] = 0.0
    target_invoice_amount: Optional[float] = 0.0

class PerformanceMatrixRow(BaseModel):
    user_id: int
    user_name: str
    
    # Column: Total GAP (Actual PO - Actual Paid)
    total_gap: float 

    # Section: PO Received
    plan_po: float
    actual_po: float
    percent_po: float

    # Section: Invoice (Paid)
    plan_invoice: float
    actual_invoice: float
    percent_invoice: float

class RejectionHistoryItem(BaseModel):
    id: int
    rejected_by: Optional[UserInfo] = None # Assuming you have a basic User schema
    comment: str
    rejected_at: datetime
    
    model_config = ConfigDict(from_attributes=True)

class BCItemCreate(BaseModel):
    merged_po_id: int
    rate_sbc: float      # e.g., 0.85
    quantity_sbc: float  # e.g., 5.0
    rejection_history: List[RejectionHistoryItem] = []

class BCCreate(BaseModel):
    internal_project_id: int
    sbc_id: int
    bc_type: str
    
    items: List[BCItemCreate]

class SBCCreate(BaseModel):
    short_name: str
    name: str
    ceo_name: Optional[str] = None
    email: Optional[str] = None
    rib: Optional[str] = None
    bank_name: Optional[str] = None
    bank_address: Optional[str] = None
    cnss: Optional[str] = None
    tax_id: Optional[str] = None
    activity_sector: Optional[str] = None
    phone_number: Optional[str] = None
    address: Optional[str] = None
    ice: Optional[str] = None
    rc: Optional[str] = None

class SBCResponse(BaseModel):
    id: int
    short_name: str
    sbc_code: str
    status: str
    name: str
    ceo_name: Optional[str] = None
    email: Optional[str] = None
    rib: Optional[str] = None
    bank_name: Optional[str] = None
    bank_address: Optional[str] = None
    ice: Optional[str] = None
    rc: Optional[str] = None
    cnss: Optional[str] = None
    tax_id: Optional[str] = None
    activity_sector: Optional[str] = None
    phone_number: Optional[str] = None
    address: Optional[str] = None
    created_at: Optional[datetime] = None 
    created_by: Optional[UserInfo] = None
    has_contract_attachment: bool
    contract_upload_date: Optional[datetime] = None
    has_tax_regularization: bool
    tax_reg_upload_date: Optional[datetime] = None
    tax_reg_end_date: Optional[date] = None
    model_config = ConfigDict(from_attributes=True)
class MergedPOSimple(BaseModel):
    id: int

    # Dans la BDD c'est un varchar style "5051G24574000-1-5"
    po_id: str

    po_no: str

    # Dans la BDD c'est un int (5, 11, 7…)
    po_line_no: int

    site_code: str

    internal_project_name: Optional[str] = None
    customer_project_name: Optional[str] = None
    item_description: str | None = None

    line_amount_hw: float
    publish_date: Optional[datetime] = None 

    class Config:
        orm_mode = True
class BCItemResponse(BCItemCreate):
    id: int
    unit_price_sbc: float
    line_amount_sbc: float
    applied_tax_rate: float
    merged_po: Optional[MergedPOBase] = None 
    qc_validation_status: Optional[str] = None
    pm_validation_status: Optional[str] = None
    global_status: Optional[str] = None
    rejection_count: Optional[int] = None

    postponed_until: Optional[datetime] = None
    act_id: Optional[int] = None
    

    model_config = ConfigDict(from_attributes=True)


class BCResponse(BaseModel):
    id: int
    bc_number: str
    internal_project: Optional[InternalProject] = None
    sbc: Optional[SBCResponse] = None
    bc_type: str
    status: str
    total_amount_ht: float
    total_tax_amount: float
    total_amount_ttc: float
    rejection_reason: Optional[str] = None
    creator: Optional[UserInfo] = None
    created_at: datetime
    items: List[BCItemResponse]
    approver_l1: Optional[UserInfo] = None
    approved_l1_at: Optional[datetime] = None
    approver_l2: Optional[UserInfo] = None
    approved_l2_at: Optional[datetime] = None
    model_config = ConfigDict(from_attributes=True)

class SiteAssignByCodeRequest(BaseModel):
    """
    Assigner 1 seul site à un projet interne
    en utilisant le site_code + le nom du projet interne.
    """
    site_code: str
    internal_project_name: str

class BatchSearchRequest(BaseModel):
    site_codes: List[str]
    start_date: Optional[date] = None # New
    end_date: Optional[date] = None
class BulkSiteAssignByCodeRequest(BaseModel):
    """
    Assigner plusieurs sites à un projet interne
    en utilisant les site_codes + le nom du projet interne.
    """
    site_codes: List[str]
    internal_project_name: str
class BulkSiteAssignment(BaseModel):
    site_ids: List[int]
    internal_project_id: int
class SiteCodeList(BaseModel):
    site_codes: List[str]



class BCRejectionRequest(BaseModel):
    reason: str

    class Config:
        orm_mode = True

class TargetUpdate(BaseModel):
    user_id: int
    year: int
    month: int
    field: str # "po_master", "po_update", "acc_master", "acc_update"
    value: float

class NotificationItem(BaseModel):
    id: int
    type: str
    title: str
    message: str
    link: Optional[str] = None
    is_read: bool
    created_at: datetime
    
    model_config = ConfigDict(from_attributes=True)

class NotificationResponse(BaseModel):
    notifications: List[NotificationItem]
    unread_count: int

    model_config = ConfigDict(from_attributes=True)

class PasswordResetRequest(BaseModel):
    token: str
    new_password: str

class ForgotPasswordRequest(BaseModel):
    email: str
class ChangePasswordSchema(BaseModel):
    current_password: str
    new_password: str

class AdminResetPasswordRequest(BaseModel):
    new_password: str
class ReviewPayload(BaseModel):
    merged_po_ids: List[int]
    action: str # "APPROVE" or "REJECT"
    comments: Optional[str] = None

class ValidationPayload(BaseModel):
    action: str # "APPROVE" or "REJECT"
    comment: Optional[str] = None

class GenerateACTPayload(BaseModel):
    item_ids: List[int]


# --- UPDATE: Detailed BC Item (Optional, if you want history nested) ---
class BCItemDetail(BCItemResponse):
    rejection_history: List[RejectionHistoryItem] = []

class BulkValidationPayload(BaseModel):
    bc_id: int
    item_ids: List[int]
    action: str
    comment: Optional[str] = None

class BCInfo(BaseModel):
    id: int
    bc_number: str
    model_config = ConfigDict(from_attributes=True)

class ServiceAcceptance(BaseModel):
    id: int
    act_number: str
    created_at: datetime
    bc: BCResponse
    creator: UserInfo
    items: List[BCItemResponse] = []
    total_amount_ht: float
    total_tax_amount: float
    total_amount_ttc: float
    bc: Optional[BCResponse] = None # Nested BC object

    model_config = ConfigDict(from_attributes=True)
class ServiceAcceptanceList(BaseModel):
    id: int
    act_number: str
    created_at: datetime
    bc: BCResponse # Nested schema
    creator: UserInfo     # Nested schema
    items: List[BCItemResponse] # Nested schema
    model_config = ConfigDict(from_attributes=True)

class ServiceAcceptanceItemDetail(BaseModel):
    id: int
    quantity_sbc: float
    unit_price_sbc: float
    line_amount_sbc: float
    applied_tax_rate: float
    # Nested PO details for description
    merged_po: Optional[MergedPOSimple] = None 
    
    model_config = ConfigDict(from_attributes=True)

class ServiceAcceptanceDetail(ServiceAcceptance): # Inherits basic fields
    items: List[ServiceAcceptanceItemDetail] = []
    model_config = ConfigDict(from_attributes=True)
class SBCKpiSummary(BaseModel):
    total_bc_value: float
    total_paid_amount: float
    pending_payment: float
    active_bc_count: int

class SbcAcceptanceItem(BaseModel):
    id: int
    
    # Details from the Parent BC/PO
    bc_number: str
    po_no: str
    site_code: str | None = None
    item_description: str | None = None
    
    # Financials (SBC Specific)
    quantity: float
    unit_price: float
    total_amount: float
    
    # Status
    status: str # READY_FOR_ACT or ACCEPTED
    act_number: Optional[str] = None # If ACT exists
    
    # Helper to flatten the data from the ORM object
    @classmethod
    def from_orm_custom(cls, item: BCItem):
        return cls(
            id=item.id,
            bc_number=item.bc.bc_number,
            po_no=item.merged_po.po_no,
            site_code=item.merged_po.site_code,
            item_description=item.merged_po.item_description,
            
            quantity=item.quantity_sbc,
            unit_price=item.unit_price_sbc, # The SBC's price
            total_amount=item.line_amount_sbc, # The SBC's total
            
            status=item.global_status,
            act_number=item.act.act_number if item.act else None
        )

class FundRequestItemCreate(BaseModel):
    pm_id: int
    amount: float
    remarque: Optional[str] = None

class FundRequestCreate(BaseModel):
    items: List[FundRequestItemCreate]

class FundRequestItemReview(BaseModel):
    item_id: int
    amount_to_pay: float # Use this name!
    admin_note: Optional[str] = None # <-- ADD THIS

class FundRequestReview(BaseModel):
    action: str # "APPROVE" or "REJECT"
    items: List[FundRequestItemReview]
class FundRequestItemDetail(BaseModel):
    id: int
    target_pm_id: int
    target_pm_name: str
    requested_amount: float
    approved_amount: Optional[float] = 0.0
    remarque: Optional[str] = None # Include remark in response
    admin_note: Optional[str] = None # <-- ADD THIS

    model_config = ConfigDict(from_attributes=True)


# Schema for the Request Details Response
class FundRequestDetail(BaseModel):
    id: int
    request_number: str
    status: str
    requester_id: int
    requester_name: str
    approver_id: Optional[int] = None
    approver_name: Optional[str] = None
    
    created_at: datetime
    approved_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    
    total_amount: float # Calculated field
    paid_amount: float # New field: How much has been paid so far
    admin_comment: Optional[str] = None # New field: Admin's note
    
    items: List[FundRequestItemDetail]

    model_config = ConfigDict(from_attributes=True)
PositiveFloat = Annotated[float, Field(gt=0)]

class ProjectSimple(BaseModel):
    id: int
    name: str
    
    model_config = ConfigDict(from_attributes=True)




class ExpenseTypeSchema(BaseModel):
    id: int
    name: str
    model_config = ConfigDict(from_attributes=True)

class ExpenseTypeCreate(BaseModel):
    name: str
class ExpenseBase(BaseModel):
    project_id: int
    exp_type: str
    beneficiary: Optional[str] = None # Optional because it might be auto-filled from ACT
    remark: Optional[str] = None
    amount: float # type: ignore
    attachment: str | None = None
    act_ids: List[int] = [] 
    is_draft: bool = False 


class ExpenseCreate(ExpenseBase):

    pass

class ServiceAcceptanceMini(BaseModel):
    id: int
    act_number: str
    total_amount_ht: float
    created_at: datetime
    
    model_config = ConfigDict(from_attributes=True)


class ExpenseResponse(BaseModel):
    id: int
    project_id: int
    internal_project: Optional[ProjectSimple] = None 
    
    exp_type: str
    amount: float
    status: str
    remark: Optional[str] = None
    beneficiary: str
    beneficiary_user_id: Optional[int] = None
    
    requester: Optional[UserBase] = None
    
    created_at: datetime
    updated_at: datetime
    
    # Workflow info
    l1_approver: Optional[UserInfo] = None
    l1_at: Optional[datetime] = None
    l2_approver: Optional[UserInfo] = None
    l2_at: Optional[datetime] = None
    
    payment_confirmed_at: Optional[datetime] = None
    signed_doc_url: Optional[str] = None 
    attachment: Optional[str] = None
    
    is_signed_copy_uploaded: bool
    acknowledged_at: Optional[datetime] = None
    
    rejection_reason: Optional[str] = None
    act_ids: List[int] = [] 
    acts: List[ServiceAcceptanceMini] = [] # <--- Add this to see the batch

    # Add a validator to populate act_ids from the 'acts' relationship
    @field_validator("act_ids", mode="before")
    @classmethod
    def extract_act_ids(cls, v, info):
        # If the input is the ORM model, 'acts' is a list of ServiceAcceptance objects
        if hasattr(info.data, 'acts'):
            return [act.id for act in info.data.acts]
        return v


class ExpenseUpdate(BaseModel):
    exp_type: str | None = None
    beneficiary: str | None = None
    remark: str | None = None
    amount: PositiveFloat | None = None # type: ignore
    attachment: str | None = None

class CaisseStats(BaseModel):
    balance: float
    reserved: float
    pending_in: float
    spent_month: float

    model_config = ConfigDict(from_attributes=True)
class ExpenseOut(BaseModel):
    id: int
    project_id: int
    exp_type: str
    beneficiary: str
    amount: float
    remark: Optional[str]
    status: str
    internal_project: Optional[ProjectSimple] = None 
    requester: Optional[UserBase] = None
    rejection_reason: Optional[str] = None
    # CHANGEZ CES DEUX LIGNES :
    created_at: datetime  # <--- Mettre datetime au lieu de str
    updated_at: datetime  # <--- Mettre datetime au lieu de str
    
    class Config:
        from_attributes = True

class FundRequestReviewAction(BaseModel):
    action: str  # "APPROVE" or "REJECT"
    close_request: bool = False
    comment: Optional[str] = None
    items: List[FundRequestItemReview]
    
    model_config = ConfigDict(from_attributes=True)


class ExpenseReject(BaseModel):
    reason: str
    
    model_config = ConfigDict(from_attributes=True)

class InternalControlUpdate(BaseModel):
    identifiers: List[str] # List of PO IDs or Site Codes
    set_to_value: int # 0 or 1





class ConfirmPaymentRequest(BaseModel):
     attachment: str

class WalletSummary(BaseModel):
    user_id: int
    user_name: str
    balance: float

    class Config:
        from_attributes = True
        
class PayableActResponse(BaseModel):
    id: int
    act_number: str
    total_amount_ht: float
    sbc_name: str
    sbc_id: Optional[int] = None # <--- Allow None to prevent crashes
    created_at: datetime

    class Config:
        from_attributes = True