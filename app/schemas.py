from typing import List, Optional
from datetime import date, datetime
from pydantic import ConfigDict

from .custom_types import FormattedDate

from .enum import ProjectType, UserRole
from pydantic import BaseModel, EmailStr
# --- 1. UserBase: Defines all the fields a user CAN have. ---
# It does NOT include fields generated by the server like `id` or `is_active`.
class UserBase(BaseModel):
    username: str
    email: str
    first_name: str
    last_name: str
    role: UserRole
    birth_date: Optional[FormattedDate] = None
    cin: Optional[str] = None
    cnss: Optional[str] = None
    rib: Optional[str] = None
    phone_number: Optional[str] = None
    address: Optional[str] = None
    city: Optional[str] = None
    hire_date: Optional[FormattedDate] = None
    job_title: Optional[str] = None
    daily_rate: Optional[float] = None


# --- 2. UserCreate: For CREATING a user. ---
# It inherits all the fields from UserBase and adds the password.
# This is the schema your /register endpoint should use for INPUT.
class UserCreate(UserBase):
    password: str


# --- 3. User: For READING a user. ---
# It inherits all the fields from UserBase and adds the server-generated fields.
# This is the schema your endpoints should use for OUTPUT.
class User(UserBase):
    id: int
    is_active: bool

    model_config = ConfigDict(from_attributes=True)
class UserUpdate(BaseModel):
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    job_title: Optional[str] = None
    hire_date: Optional[date] = None
    phone_number: Optional[str] = None
    email: Optional[EmailStr] = None
    role: Optional[str] = None

model_config = ConfigDict(from_attributes=True)
class AccountBase(BaseModel):
    name: str

class AccountCreate(AccountBase):
    pass

class Account(AccountBase):
    id: int
    model_config = ConfigDict(from_attributes=True)

class CustomerBase(BaseModel):
    name: str
    short_name: Optional[str] = None

class CustomerCreate(CustomerBase):
    pass

class Customer(CustomerBase):
    id: int
    model_config = ConfigDict(from_attributes=True)


class ProjectBase(BaseModel):
    name: str
    
    # --- CHANGE 1: Use the Enum for project_type ---
    project_type: Optional[ProjectType] = None
    
    start_date: Optional[FormattedDate] = None
    plan_end_date: Optional[FormattedDate] = None
    has_extension_possibility: Optional[bool] = False
    
    # We are removing project_manager_name
    
    forecast_plan_details: Optional[str] = None
    budget_assigned: Optional[float] = None
    budget_period: Optional[str] = None
    
    # We will accept IDs for the related objects
    account_id: Optional[int] = None
    direct_customer_id: Optional[int] = None
    final_customer_id: Optional[int] = None
    
    # --- CHANGE 2: Accept a project_manager_id ---
    project_manager_id: Optional[int] = None

class ProjectCreate(ProjectBase):
    pass

# This schema is for reading a Project. It will include the full nested objects.
class Project(ProjectBase):
    id: int
    account: Optional[Account] = None
    direct_customer: Optional[Customer] = None
    final_customer: Optional[Customer] = None
    
    # --- CHANGE 3: Return the full User object ---
    project_manager: Optional[User] = None
    
    model_config = ConfigDict(from_attributes=True)

class PurchaseOrderBase(BaseModel):
    due_qty: float
    po_status: str
    unit_price: float
    line_amount: float
    billed_quantity: float
    po_no: str
    po_line_no: int
    item_code: str
    requested_qty: float
    publish_date: FormattedDate
    project_code: str
    payment_terms_raw: Optional[str] = None # Add to schema

class PurchaseOrderCreate(PurchaseOrderBase):
    pass

class RawPurchaseOrder(PurchaseOrderBase):
    id: int
    is_processed: bool
    model_config = ConfigDict(from_attributes=True)
class InternalProject(BaseModel):
    id: int
    name: str
    project_manager: Optional[User] = None
    project_type: Optional[ProjectType] = None
    start_date: Optional[FormattedDate] = None
    plan_end_date: Optional[FormattedDate] = None
    has_extension_possibility: Optional[bool] = None
    forecast_plan_details: Optional[str] = None
    budget_assigned: Optional[float] = None
    budget_period: Optional[str] = None
    account: Optional[Account] = None
    direct_customer: Optional[Customer] = None
    final_customer: Optional[Customer] = None

    model_config = ConfigDict(from_attributes=True)
class InternalProjectCreate(BaseModel):
    name: str
    # Use the Enum here
    project_type: ProjectType 
    
    # Dates can be passed as YYYY-MM-DD strings, Pydantic handles the parsing
    start_date: Optional[date] = None
    plan_end_date: Optional[date] = None
    
    has_extension_possibility: bool = False
    forecast_plan_details: Optional[str] = None
    budget_assigned: Optional[float] = None
    budget_period: Optional[str] = None
    
    # Foreign Keys
    project_manager_id: Optional[int] = None
    account_id: Optional[int] = None
    direct_customer_id: Optional[int] = None
    final_customer_id: Optional[int] = None
class InternalProjectUpdate(InternalProjectCreate):
    pass

class CustomerProject(BaseModel):
    id: int
    name: str
    
    model_config = ConfigDict(from_attributes=True)
class SiteAssignmentRuleCreate(BaseModel):
    # All criteria are optional, but at least one should ideally be provided
    starts_with: Optional[str] = None
    ends_with: Optional[str] = None
    contains_str: Optional[str] = None
    
    customer_project_id: Optional[int] = None
    
    min_publish_date: Optional[date] = None
    max_publish_date: Optional[date] = None
        
    internal_project_id: int # Mandatory target

class SiteAssignmentRule(SiteAssignmentRuleCreate):
    id: int
    # We include nested objects for the UI table
    internal_project: Optional[InternalProject] = None 
    customer_project: Optional[CustomerProject] = None # Assuming you have a basic schema for this
    
    model_config = ConfigDict(from_attributes=True)
class SiteAllocationCreate(BaseModel):
    site_id: int
    internal_project_id: int

class MergedPOBase(BaseModel):
    po_id: str
    customer_project: CustomerProject # This will be a nested object
    site_code: Optional[str] = None
    internal_project: Optional[InternalProject] = None 

    po_no: str
    po_line_no: int
    item_description: Optional[str] = None
    payment_term: str
    unit_price: float
    requested_qty: float
    internal_control: int
    line_amount_hw: float
    publish_date: FormattedDate
    category: Optional[str] = None
    total_ac_amount: Optional[float] = None
    accepted_ac_amount: Optional[float] = None
    date_ac_ok: Optional[date] = None
  
    total_pac_amount: Optional[float] = None
    accepted_pac_amount: Optional[float] = None
    date_pac_ok: Optional[date] = None
    model_config = ConfigDict(from_attributes=True)

class MergedPO(MergedPOBase):
    id: int
    model_config = ConfigDict(from_attributes=True)
class RemainingPO(MergedPO):
    remaining_amount: float
    remaining_stage: str # "AC" or "PAC"
    
    model_config = ConfigDict(from_attributes=True)

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

# in backend/app/schemas.py

# We already have a User schema for nesting, which is perfect.
# class User(UserBase): ...

class UploadHistoryBase(BaseModel):
    original_filename: str
    status: str
    total_rows: int
    error_message: Optional[str] = None

class UploadHistory(UploadHistoryBase):
    id: int
    uploaded_at: datetime
    uploader: User # Nest the full user object

    model_config = ConfigDict(from_attributes=True)


class PaginatedMergedPO(BaseModel):
    items: List[MergedPO]
    total_items: int
    page: int
    per_page: int
    total_pages: int

class PageSite(BaseModel):
    items: List["Site"]
    total_items: int
    page: int
    per_page: int
    total_pages: int
class SiteBase(BaseModel):
    site_code: str
    site_name: Optional[str] = None

class Site(SiteBase):
    id: int
    
    model_config = ConfigDict(from_attributes=True)
class FinancialSummary(BaseModel):
    total_po_value: float
    total_accepted_ac: float
    total_accepted_pac: float
    remaining_gap: float
   

class ProjectFinancials(BaseModel):
    project_id: int
    project_name: str
    total_po_value: float
    total_accepted: float
    remaining_gap: float
    completion_percentage: float

class MonthlyChartData(BaseModel):
    month: int
    total_po_value: float
    total_paid: float
    
class ProjectTargetSummary(BaseModel):
    project_name: str
    pm_name: str
    planned_budget: float
    actual_spent: float
    target_budget: float
    completion_rate: float

    model_config = ConfigDict(from_attributes=True)
class UserPerformanceSummary(BaseModel):
    total_po_value: float
    total_accepted: float
    remaining_gap: float
    completion_percentage: float
class UserTargetCreate(BaseModel):
    user_id: int
    year: int
    month: int
    target_po_amount: Optional[float] = 0.0
    target_invoice_amount: Optional[float] = 0.0

class PerformanceMatrixRow(BaseModel):
    user_id: int
    user_name: str
    
    # Column: Total GAP (Actual PO - Actual Paid)
    total_gap: float 

    # Section: PO Received
    plan_po: float
    actual_po: float
    percent_po: float

    # Section: Invoice (Paid)
    plan_invoice: float
    actual_invoice: float
    percent_invoice: float
class BCItemCreate(BaseModel):
    merged_po_id: int
    rate_sbc: float      # e.g., 0.85
    quantity_sbc: float  # e.g., 5.0

class BCCreate(BaseModel):
    internal_project_id: int
    sbc_id: int
    items: List[BCItemCreate]

class SBCCreate(BaseModel):
    short_name: str
    name: str
    ceo_name: Optional[str] = None
    email: Optional[str] = None
    rib: Optional[str] = None
    bank_name: Optional[str] = None
    bank_address: Optional[str] = None
    cnss: Optional[str] = None
    tax_id: Optional[str] = None
    activity_sector: Optional[str] = None
    phone_number: Optional[str] = None
    address: Optional[str] = None


class SBCResponse(BaseModel):
    id: int
    short_name: str
    sbc_code: str
    status: str
    name: str
    ceo_name: Optional[str] = None
    email: Optional[str] = None
    rib: Optional[str] = None
    bank_name: Optional[str] = None
    bank_address: Optional[str] = None
    cnss: Optional[str] = None
    tax_id: Optional[str] = None
    activity_sector: Optional[str] = None
    phone_number: Optional[str] = None
    address: Optional[str] = None
    created_at: datetime

class MergedPOSimple(BaseModel):
    id: int

    # Dans la BDD c'est un varchar style "5051G24574000-1-5"
    po_id: str

    po_no: str

    # Dans la BDD c'est un int (5, 11, 7…)
    po_line_no: int

    site_code: str

    internal_project_name: Optional[str] = None
    customer_project_name: Optional[str] = None
    item_description: str | None = None

    line_amount_hw: float
    publish_date: Optional[datetime] = None 

    class Config:
        orm_mode = True
class BCItemResponse(BCItemCreate):
    id: int
    unit_price_sbc: float
    line_amount_sbc: float
    applied_tax_rate: float
    merged_po: Optional[MergedPOSimple] = None 

    model_config = ConfigDict(from_attributes=True)

class BCResponse(BaseModel):
    id: int
    bc_number: str
    status: str
    total_amount_ht: float
    total_tax_amount: float
    total_amount_ttc: float
    rejection_reason: Optional[str] = None
    created_at: datetime
    items: List[BCItemResponse]
    model_config = ConfigDict(from_attributes=True)

class SiteAssignByCodeRequest(BaseModel):
    """
    Assigner 1 seul site à un projet interne
    en utilisant le site_code + le nom du projet interne.
    """
    site_code: str
    internal_project_name: str

class BatchSearchRequest(BaseModel):
    site_codes: List[str]
    start_date: Optional[date] = None # New
    end_date: Optional[date] = None
class BulkSiteAssignByCodeRequest(BaseModel):
    """
    Assigner plusieurs sites à un projet interne
    en utilisant les site_codes + le nom du projet interne.
    """
    site_codes: List[str]
    internal_project_name: str
class BulkSiteAssignment(BaseModel):
    site_ids: List[int]
    internal_project_id: int
class SiteCodeList(BaseModel):
    site_codes: List[str]



class BCRejectionRequest(BaseModel):
    reason: str

    class Config:
        orm_mode = True



